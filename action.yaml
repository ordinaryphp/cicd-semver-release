name: 'Create CI/CD Semver Release'
description: 'Automatically create a release on pull request completion.'
inputs:
  token:
    type: string
    description: 'Custom app or personal access token to use for release creation. (Required if tag push should trigger a workflow)'
  prefix:
    type: string
    description: 'Prefix to add to semver'
    default: 'v'
  suffix:
    type: string
    description: 'Suffix to add to semver'
    default: ''
  strict_semver_last:
    type: boolean
    description: 'When detecting last semver, requires the semver to have the configured prefix and suffix'
    default: false
  create_release:
    type: boolean
    default: true
  create_if_pr_complete:
    type: boolean
    description: 'Disable to allow release creation when trigger is not a completed pull request'
    default: true
  enhancement_label:
    type: string
    description: 'Label that indicates changes includes enhancements or new features'
    default: enhancement
  bug_label:
    type: string
    description: 'Label that indicates changes includes bug fixes'
    default: bug
  backward_compatible_label:
    type: string
    description: 'Label that indicates changes are backward compatible'
    default: backward-compatible
  not_backward_compatible_label:
    type: string
    description: 'Label that indicates changes are not backward compatible'
    default: not-backward-compatible
outputs:
  tag_last:
    description: "Last semver tag detected"
    value: ${{ steps.semver_last.outputs.last_tag }}
  semver_last:
    description: "Last semver detected"
    value: ${{ steps.semver_last.outputs.last_semver }}
  tag_next:
    description: "Next semver tag to be created"
    value: ${{ steps.semver_next.outputs.next_tag }}
  semver_next:
    description: "Next semver to be created"
    value: ${{ steps.semver_next.outputs.next_semver }}
  change_compatibility:
    description: "Change compatibility"
    value: ${{ steps.pr_data.outputs.change_compatibility }}
  change_type:
    description: "Change type"
    value: ${{ steps.pr_data.outputs.change_type }}
runs:
  using: "composite"
  steps:
    - name: Validate Event
      shell: bash
      env:
        eventType: ${{ github.event_name }}
      # language=BASH
      run: |
        if [ "$eventType" != "pull_request" ]; then
          echo "This action is only valid on pull request events" >&2
          exit 1
        fi
    - name: 'Get Labels'
      id: get_labels
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
      # language=BASH
      run: |
        set +e
        prPayloadUrl="repos/$GITHUB_REPOSITORY/pulls/$PR_NUMBER"
        
        echo "GH Api Get: $prPayloadUrl"
        
        response="$(gh api -H "Accept: application/vnd.github+json" "$prPayloadUrl")"
        
        if [ $? -ne 0 ]; then
          echo "Api request failed" >&2
          exit 1
        fi
        
        labels="$(jq -c '[.labels[].name]' <<< "$response")"
        
        echo "Labels: $labels"
        echo "pr_labels=$labels" >> "$GITHUB_OUTPUT"
    - name: 'Get Pull Request Data'
      id: pr_data
      shell: bash
      env:
        isBug: ${{ contains(fromJSON(steps.get_labels.outputs.pr_labels), inputs.bug_label) }}
        isEnhancement: ${{ contains(fromJSON(steps.get_labels.outputs.pr_labels), inputs.enhancement_label) }}
        isBc: ${{ contains(fromJSON(steps.get_labels.outputs.pr_labels), inputs.backward_compatible_label) }}
        isNotBc: ${{ contains(fromJSON(steps.get_labels.outputs.pr_labels), inputs.not_backward_compatible_label) }}
      # language=BASH
      run: |
        set +e
        hasError=false
        
        if [ "$isBug" == "false" ] && [ "$isEnhancement" == "false" ]; then
          echo "Missing ONE of required tags (bug || enhancement)" >&2
          hasError=true
        fi
        
        if [ "$isBug" == "true" ] && [ "$isEnhancement" == "true" ]; then
          echo "Conflicting tags (bug && enhancement)" >&2
          hasError=true
        fi
        
        if [ "$isBc" == "false" ] && [ "$isNotBc" == "false" ]; then
          echo "Missing ONE of required tags (backward-compatible || not-backward-compatible)" >&2
          hasError=true
        fi
        
        if [ "$isBc" == "true" ] && [ "$isNotBc" == "true" ]; then
          echo "Conflicting tags (backward-compatible && not-backward-compatible)" >&2
          hasError=true
        fi
        
        if [ "$hasError" == "true" ]; then
         exit 1
        fi
        
        [ "$isBc" == "true" ] && changeCompat="backward-compatible"
        [ "$isNotBc" == "true" ] && changeCompat="not-backward-compatible"
        [ "$isBug" == "true" ] && changeType="bug"
        [ "$isEnhancement" == "true" ] && changeType="enhancement"
        
        echo "Change Type: $changeType"
        echo "Compatibility Type: $changeCompat"
        
        echo "change_type=$changeType" >> "$GITHUB_OUTPUT"
        echo "change_compatibility=$changeCompat" >> "$GITHUB_OUTPUT"
    - uses: octokit/request-action@v2.x
      id: get_tags
      with:
        route: GET /repos/${{ github.repository }}/git/matching-refs/tags
      env:
        GITHUB_TOKEN: ${{ github.token }}
    - name: 'Get Last Semver'
      id: semver_last
      shell: bash
      env:
        isMergeComplete: github.event.pull_request.merged
        strictSemver: ${{ inputs.strict_semver_last }}
        mergeCommit: ${{ github.event.pull_request.merge_commit_sha }}
        tagList: ${{ join(steps.get_tags.outputs.data.*.ref, '\n') }}
      # language=BASH
      run: |
        set +e
        
        echo "Strict semver matching: $strictSemver"
        echo "Tags: $tagList"
        
        function filterPrefix() {
          prefix='${{ inputs.prefix }}'
        
          if [ -z "$prefix" ] || [ "$strictSemver" == "false" ]; then
            cat
            return 0
          fi
        
          while read -r line; do
            if [ "${line:0:${#prefix}}" == "$prefix" ]; then
              echo "$line"
            else
              echo "Skipped by prefix $line"
            fi
          done
        }
        
        function filterSuffix() {
          suffix='${{ inputs.suffix }}'
        
          if [ -z "$suffix" ] || [ "$strictSemver" == "false" ]; then
            cat
            return 0
          fi
        
          while read -r line; do
            if [ "${line: ${#suffix}}" == "$suffix" ]; then
              echo "$line"
            else
              echo "Skipped by prefix $line"
            fi
          done
        }
        
        if [ "$isMergeComplete" == "true" ]; then
          existingMergeTag="$(git describe --tags --exact-match "$mergeCommit" | filterPrefix | filterSuffix)"
        
          if [ -z "$existingMergeTag" ]; then
            echo "Existing semver tag found on current merge commit $existingMergeTag ($mergeCommit)" >&2
            exit 1
          fi
        fi
        
        echo "Tags: $(git tag)"
        tagMatch="$(echo "$tagList" | filterPrefix | filterSuffix | head -n 1)"
        
        if [ -z "$tagMatch" ]; then
          echo "No tag found - assuming semver 0.0.0 as last tag"
          semverMatch="0.0.0"
        else
          semverMatch="$(echo "$tagMatch" | grep -Po '(?<!\d)\d+\.\d+\.\d+(?!\d)')"
        fi
        
        IFS=. read lastMajor lastMinor lastPatch <<< "$semverMatch"
        
        echo "Last tag: ${tagMatch:-(NONE)}"
        echo "Last semver: $semverMatch"
        echo "  Major: $lastMajor"
        echo "  Minor: $lastMinor"
        echo "  Patch: $lastPatch"
        
        echo "last_tag=$tagMatch" >> "$GITHUB_OUTPUT"
        echo "last_semver=$semverMatch" >> "$GITHUB_OUTPUT"
        echo "last_major=$lastMajor" >> "$GITHUB_OUTPUT"
        echo "last_minor=$lastMinor" >> "$GITHUB_OUTPUT"
        echo "last_patch=$lastPatch" >> "$GITHUB_OUTPUT"
    - name: "Get next semver"
      id: semver_next
      shell: bash
      env:
        changeType: ${{ steps.pr_data.outputs.change_type }}
        changeCompatibility: ${{ steps.pr_data.outputs.change_compatibility }}
      # language=BASH
      run: |
        set +e
        semverMajor='${{ steps.semver_last.outputs.last_major }}'
        semverMinor='${{ steps.semver_last.outputs.last_minor }}'
        semverPatch='${{ steps.semver_last.outputs.last_patch }}'
        
        case "$changeCompatibility:$changeType" in
          not-backward-compatible:*)
            ((semverMajor++))
            semverMinor=0
            semverPatch=0
            ;;
          backward-compatible:enhancement)
            ((semverMinor++))
            semverPatch=0
            ;;
          backward-compatible:bug)
            ((semverPatch++))
            ;;
          *)
            echo "Unsupported change type $changeCompatibility:$changeType" >&2
            exit 1
            ;;
        esac
        
        prefix='${{ inputs.prefix }}'
        suffix='${{ inputs.suffix }}'
        
        semverNext="$semverMajor.$semverMinor.$semverPatch"
        tagNext="${prefix}${semverNext}${suffix}"
        
        echo "Next Semver: $semverNext"
        echo "Next Tag: $tagNext"
        
        echo "next_semver=$semverNext" >> "$GITHUB_OUTPUT"
        echo "next_tag=$tagNext" >> "$GITHUB_OUTPUT"
    - name: 'Create Release'
      id: create_release
      if: inputs.create_release && (!inputs.create_if_pr_complete || github.event.pull_request.merged == true)
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token || github.token }}
        releaseTag: ${{ steps.semver_next.outputs.next_tag }}
        releaseSemver: ${{ steps.semver_next.outputs.next_semver }}
        mergeCommit: ${{ github.event.pull_request.merge_commit_sha }}
      # language=BASH
      run: |
        set -e
        
        echo "Creating release"
        gh release create "$releaseTag" --target "$mergeCommit" --title "Release: $releaseSemver ($releaseTag)" --generate-notes --latest
